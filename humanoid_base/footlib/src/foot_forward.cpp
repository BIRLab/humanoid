//
// File: foot_forward.cpp
//
// MATLAB Coder version            : 5.4
// C/C++ source code generated on  : 24-Aug-2023 18:26:44
//

// Include Files
#include "foot_forward.h"
#include "rt_nonfinite.h"
#include "rt_defines.h"
#include <cmath>

// Function Declarations
static double rt_atan2d_snf(double u0, double u1);

// Function Definitions
//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_atan2d_snf(double u0, double u1)
{
  double y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else if (std::isinf(u0) && std::isinf(u1)) {
    int b_u0;
    int b_u1;
    if (u0 > 0.0) {
      b_u0 = 1;
    } else {
      b_u0 = -1;
    }
    if (u1 > 0.0) {
      b_u1 = 1;
    } else {
      b_u1 = -1;
    }
    y = std::atan2(static_cast<double>(b_u0), static_cast<double>(b_u1));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = std::atan2(u0, u1);
  }
  return y;
}

//
// FOOT_FORWARD
//     Y = FOOT_FORWARD(ROLL,PITCH)
//
// Arguments    : double roll
//                double pitch
//                double y[2]
// Return Type  : void
//
void foot_forward(double roll, double pitch, double y[2])
{
  double a;
  double a_tmp;
  double a_tmp_tmp;
  double b_a;
  double b_a_tmp;
  double b_a_tmp_tmp;
  double b_et1_tmp_tmp;
  double c_a_tmp;
  double c_a_tmp_tmp;
  double d_a_tmp;
  double d_a_tmp_tmp;
  double e_a_tmp;
  double e_a_tmp_tmp;
  double et1_tmp_tmp;
  double f_a_tmp;
  double f_a_tmp_tmp;
  //     This function was generated by the Symbolic Math Toolbox version 9.1.
  //     24-Aug-2023 16:58:59
  et1_tmp_tmp = std::sin(pitch);
  b_et1_tmp_tmp = std::cos(pitch);
  a_tmp_tmp = std::cos(roll);
  b_a_tmp_tmp = std::sin(roll);
  c_a_tmp_tmp = a_tmp_tmp * 16.5;
  d_a_tmp_tmp = b_a_tmp_tmp * 16.0;
  a_tmp = c_a_tmp_tmp + d_a_tmp_tmp;
  e_a_tmp_tmp = b_et1_tmp_tmp * 47.2;
  f_a_tmp_tmp = et1_tmp_tmp * a_tmp;
  b_a_tmp = e_a_tmp_tmp + f_a_tmp_tmp;
  a_tmp *= b_et1_tmp_tmp;
  c_a_tmp = et1_tmp_tmp * -4720.0;
  d_a_tmp = (c_a_tmp + a_tmp * 100.0) + 23200.0;
  e_a_tmp = et1_tmp_tmp * -47.2;
  a = (e_a_tmp + a_tmp) + 232.0;
  a_tmp = b_a_tmp_tmp * 16.5;
  b_a = (a_tmp_tmp * -16.0 + a_tmp) + 16.0;
  f_a_tmp = c_a_tmp_tmp - d_a_tmp_tmp;
  b_a_tmp_tmp = et1_tmp_tmp * f_a_tmp;
  c_a_tmp_tmp = e_a_tmp_tmp + b_a_tmp_tmp;
  f_a_tmp *= b_et1_tmp_tmp;
  c_a_tmp = (c_a_tmp + f_a_tmp * 100.0) + 29000.0;
  f_a_tmp = (e_a_tmp + f_a_tmp) + 290.0;
  d_a_tmp_tmp = (a_tmp_tmp * 16.0 + a_tmp) - 16.0;
  c_a_tmp_tmp *= c_a_tmp_tmp;
  y[0] =
      -rt_atan2d_snf(b_et1_tmp_tmp * -4720.0 - b_a_tmp_tmp * 100.0, c_a_tmp) +
      -std::asin(
          1.0 / std::sqrt(c_a_tmp_tmp + c_a_tmp * c_a_tmp / 10000.0) *
          (((c_a_tmp_tmp + f_a_tmp * f_a_tmp) + d_a_tmp_tmp * d_a_tmp_tmp) -
           81600.0) /
          100.0);
  c_a_tmp_tmp = b_a_tmp * b_a_tmp;
  y[1] =
      -rt_atan2d_snf(b_et1_tmp_tmp * -4720.0 - f_a_tmp_tmp * 100.0, d_a_tmp) +
      -std::asin(1.0 / std::sqrt(c_a_tmp_tmp + d_a_tmp * d_a_tmp / 10000.0) *
                 (((c_a_tmp_tmp + a * a) + b_a * b_a) - 51324.0) / 100.0);
}

//
// File trailer for foot_forward.cpp
//
// [EOF]
//
